
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module stopwatch(

	//////////// CLOCK //////////
	input 		          		CLOCK_50,
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW
);

//=======================================================
//  REG/WIRE declarations
//=======================================================
wire CLOCK_10;
wire CLOCK_10MS;
wire [63:0] cnt[9:0];
reg [63:0] disp_cnt;
wire [3:0] cs[1:0], s[1:0], m[1:0];
wire ready;
wire [6:0] hex[5:0];

//=======================================================
//  Structural coding
//=======================================================
pll pll(
	.refclk(CLOCK_50),
	.outclk_0(CLOCK_10),
	.rst(!KEY[0]),
	.locked(ready)
);

clk_10_to_10ms clk_div(
	.clk_10(CLOCK_10),
	.clk_10ms(CLOCK_10MS),
	.n_reset(KEY[0])
);

counter counter(
	.en(1),
	.n_reset(KEY[0] & ready),
	.clk(CLOCK_10),
	.cnt(cnt[0])
);

always @(posedge CLOCK_10MS)
	disp_cnt = cnt[0];

timedecoder decoder(
	.cnt(disp_cnt),
	.cs0(cs[0]),
	.cs1(cs[1]),
	.s0(s[0]),
	.s1(s[1]),
	.m0(m[0]),
	.m1(m[1])
);

assign HEX0 = hex[0] | ~{7{ready}};
assign HEX1 = hex[1] | ~{7{ready}};
assign HEX2 = hex[2] | ~{7{ready}};
assign HEX3 = hex[3] | ~{7{ready}};
assign HEX4 = hex[4] | ~{7{ready}};
assign HEX5 = hex[5] | ~{7{ready}};
segdriver driver0(
	.hex(cs[0]),
	.seg(hex[0])
);

segdriver driver1(
	.hex(cs[1]),
	.seg(hex[1])
);

segdriver driver2(
	.hex(s[0]),
	.seg(hex[2])
);

segdriver driver3(
	.hex(s[1]),
	.seg(hex[3])
);

segdriver driver4(
	.hex(m[0]),
	.seg(hex[4])
);

segdriver driver5(
	.hex(m[1]),
	.seg(hex[5])
);

endmodule
